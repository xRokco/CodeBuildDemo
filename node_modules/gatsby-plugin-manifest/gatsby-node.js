"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var fs = require("fs");

var path = require("path");

var Promise = require("bluebird");

var sharp = require("sharp");

var _require = require("./common.js"),
    defaultIcons = _require.defaultIcons,
    doesIconExist = _require.doesIconExist,
    addDigestToPath = _require.addDigestToPath,
    createContentDigest = _require.createContentDigest;

sharp.simd(true);

try {
  // Handle Sharp's concurrency based on the Gatsby CPU count
  // See: http://sharp.pixelplumbing.com/en/stable/api-utility/#concurrency
  // See: https://www.gatsbyjs.org/docs/multi-core-builds/
  var cpuCoreCount = require("gatsby/dist/utils/cpu-core-count");

  sharp.concurrency(cpuCoreCount());
} catch (_unused) {// if above throws error this probably means that used Gatsby version
  // doesn't support cpu-core-count utility.
}

function generateIcons(icons, srcIcon) {
  return Promise.map(icons, function (icon) {
    var size = parseInt(icon.sizes.substring(0, icon.sizes.lastIndexOf("x")));
    var imgPath = path.join("public", icon.src); // For vector graphics, instruct sharp to use a pixel density
    // suitable for the resolution we're rasterizing to.
    // For pixel graphics sources this has no effect.
    // Sharp accept density from 1 to 2400

    var density = Math.min(2400, Math.max(1, size));
    return sharp(srcIcon, {
      density: density
    }).resize({
      width: size,
      height: size,
      fit: "contain",
      background: {
        r: 255,
        g: 255,
        b: 255,
        alpha: 0
      }
    }).toFile(imgPath);
  });
}

exports.onPostBootstrap =
/*#__PURE__*/
function () {
  var _ref2 = (0, _asyncToGenerator2.default)(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(_ref, pluginOptions) {
    var reporter, icon, manifest, iconPath, sharpIcon, metadata, cacheMode, iconDigest;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reporter = _ref.reporter;
            icon = pluginOptions.icon, manifest = (0, _objectWithoutPropertiesLoose2.default)(pluginOptions, ["icon"]); // Delete options we won't pass to the manifest.webmanifest.

            delete manifest.plugins;
            delete manifest.legacy;
            delete manifest.theme_color_in_head;
            delete manifest.cache_busting_mode;
            delete manifest.crossOrigin;
            delete manifest.icon_options; // If icons are not manually defined, use the default icon set.

            if (!manifest.icons) {
              manifest.icons = defaultIcons;
            } // Specify extra options for each icon (if requested).


            if (pluginOptions.icon_options) {
              manifest.icons = manifest.icons.map(function (icon) {
                return (0, _extends2.default)({}, pluginOptions.icon_options, icon);
              });
            } // Determine destination path for icons.


            iconPath = path.join("public", path.dirname(manifest.icons[0].src)); //create destination directory if it doesn't exist

            if (!fs.existsSync(iconPath)) {
              fs.mkdirSync(iconPath);
            } // Only auto-generate icons if a src icon is defined.


            if (!(icon !== undefined)) {
              _context.next = 28;
              break;
            }

            if (doesIconExist(icon)) {
              _context.next = 15;
              break;
            }

            throw "icon (" + icon + ") does not exist as defined in gatsby-config.js. Make sure the file exists relative to the root of the site.";

          case 15:
            sharpIcon = sharp(icon);
            _context.next = 18;
            return sharpIcon.metadata();

          case 18:
            metadata = _context.sent;

            if (metadata.width !== metadata.height) {
              reporter.warn("The icon(" + icon + ") you provided to 'gatsby-plugin-manifest' is not square.\n" + "The icons we generate will be square and for the best results we recommend you provide a square icon.\n");
            } //add cache busting


            cacheMode = typeof pluginOptions.cache_busting_mode !== "undefined" ? pluginOptions.cache_busting_mode : "query"; //if cacheBusting is being done via url query icons must be generated before cache busting runs

            if (!(cacheMode === "query")) {
              _context.next = 24;
              break;
            }

            _context.next = 24;
            return generateIcons(manifest.icons, icon);

          case 24:
            if (cacheMode !== "none") {
              iconDigest = createContentDigest(fs.readFileSync(icon));
              manifest.icons.forEach(function (icon) {
                icon.src = addDigestToPath(icon.src, iconDigest, cacheMode);
              });
            } //if file names are being modified by cacheBusting icons must be generated after cache busting runs


            if (!(cacheMode !== "query")) {
              _context.next = 28;
              break;
            }

            _context.next = 28;
            return generateIcons(manifest.icons, icon);

          case 28:
            //Write manifest
            fs.writeFileSync(path.join("public", "manifest.webmanifest"), JSON.stringify(manifest));

          case 29:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function (_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();